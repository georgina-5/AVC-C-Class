/* AVC Project: Team 8
Quadrant 2 */
#include <iostream>
#include <stdio.h>
#include <unistd.h>
#include "E101.h"
#include <time.h>
using namespace std;
//CHANGE CODING FORMATING, USE CLASSES NOT JUST IN ONE MAIN
int main()
{
init(0);
open_screen_stream();
int Count = 0;
int Count_Y = 120;
int Count_X = 0;
int sample_array[13];
int error = 0;
bool backwards_check = false;
int check_red = 0;
int Neutral_Speed = 48;   //not moving
int Left_Speed = 52;				///min 31, base 48, max 59
int Right_Speed = 52;
set_motors(1,Left_Speed);			//LEFT MOTOR
set_motors(5,Right_Speed);			//RIGHT MOTOR
set_motors(3, 48);					//CAMERA
hardware_exchange();
double maxColor=0;
double minColor=200;
double threshold;

	while(true){					
		for(int row=0; row<240; row++){       //for loop calculates 'threshold' value to find what value is black/white
			for(int col=0; col<320; col++){
				int pixel = (int)get_pixel(row,col,3);
				if(pixel>maxColor){
					maxColor = pixel;
					}
					if(pixel<minColor){
					minColor = pixel;
					}
				}
			}
			threshold = (maxColor + minColor)/2;											
		
		                                                                 //quadrant 2 ends at red square, 160 is just a test value		check_red < 160
		//THIS "FOR LOOP" READS PIXELS AND DECIDES IF IT IS BLACK OR WHITE
		for (Count_X = 4; Count_X < 317; Count_X = Count_X + 26){			//puts values from a[0] to a[12]
			sample_array[Count] = (int)get_pixel(Count_Y, Count_X, 3);
			if (sample_array[Count] > threshold){									//if light is above the threshold value,
				sample_array[Count] = 1;									//then that pixel will be determined to be "white"
			}
			else{															//else that pixel will be determined to be "black"
				sample_array[Count] = 0;
			}
			//cout<<"Count = "<<Count<<endl;
			//cout<<"X = "<<Count_X<<endl;
			check_red += (int)get_pixel(Count_Y, Count_X, 0);
			//cout<<"Red = "<<check_red<<endl;
			Count++;
		}
		Count = 0;

		//THIS "FOR LOOP" READS THE ARRAY: CALCULATES THE ERROR, AND ADJUSTS THE MOTOR SPEEDS 
		for(int sample_number = 0; sample_number < 14; sample_number++){
			if (sample_array[sample_number] == 1){
				error += ((sample_number) - 6);
			}
		}
		
		//CHECKS IF IT SHOULD GO BACKWARDS
		   if(threshold<10){    //might have to chnage this value- need to test                                     
			    backwards_check = true;                 
		}
		
		cout<<"Error = "<<error<<endl;
		sleep(1);
		//UPDATING MOTOR SPEEDS
														
		if(backwards_check== false){   //update motor speed values	
		set_motors(1,43-(error*0.02));
		set_motors(5,53-(error*0.02));
		hardware_exchange();
		}	
		else{
			set_motors(1,51);
			set_motors(5,45);
			hardware_exchange();
			}
								
		//cout<<"error = "<<error<<endl;
		//cout<<"Left = "<<Left_Speed<<endl;
		//cout<<"Right = "<<Right_Speed<<endl;
		error = 0;
		check_red = 0;
		backwards_check = false;
		take_picture();
		update_screen();
	}
}
